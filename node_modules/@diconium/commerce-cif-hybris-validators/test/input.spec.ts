/*
 * Copyright 2019 diconium
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { expect } from 'chai';
import { Validator } from '../src';
import { Cart } from '@adobe/commerce-cif-model';
import TestCartMapper from './TestCartMapper';

describe('Input class ', () => {
  describe('Unit tests', () => {

    const args = {
      HB_API_HOST: 'b2c-accelerator.test.diconium.com',
      HB_AUTH_HOST: 'b2c-accelerator.test.diconium.com',
      HB_AUTH: 'basic',
      HB_BASESITEID: 'electronics',
      HB_USER: 'hybris_demo',
      HB_PASSWORD: 'go4hdemo',
      id: '12345',
      currency: 'US',
      offset: 10,
      limit: 3,
      __ow_headers: {
        cookie: 'ccs-access_token=xx508xx63817x752xx74004x30705xx92x58349x5x78f5xx34xxxxx51',
        'accept-language': 'en',
        authorization: 'Bearer xx508xx63817x752xx74004x30705xx92x58349x5x78f5xx34xxxxx51',
      },
    };

    it('Constructor should create an Object', () => {
      const validator = new Validator<Cart>(args, 'test');
      expect(validator).to.be.a('Object');
    });

    it('Input setting should be according to the input values', () => {
      const validator = new Validator<Cart>(args, 'test');
      const input = validator.setMapper(TestCartMapper).input();
      expect(input.settings.bearer).to.be.equal('xx508xx63817x752xx74004x30705xx92x58349x5x78f5xx34xxxxx51');
      expect(input.settings.HB_API_HOST).to.be.equal('b2c-accelerator.test.diconium.com');
      expect(input.settings.HB_BASESITEID).to.be.equal('electronics');
      expect(input.settings.language).to.be.equal('en');
      expect(input.settings.headers).to.be.deep.equal(args.__ow_headers);
      expect(input.settings.cookies[0]).to.be.deep.equal({ 'ccs-access_token': 'xx508xx63817x752xx74004x30705xx92x58349x5x78f5xx34xxxxx51' });
    });

    it('Input settings bearer should be according to authorization header', () => {
      const args = {
        __ow_headers: {
          authorization: 'Bearer xx508xx63817x752xx74004x30705xx92x58349x5x78f5xx34xxxxx51',
        },
      };
      const validator = new Validator<Cart>(args, 'test');
      const input = validator.setMapper(TestCartMapper).input();
      expect(input.settings.bearer).to.be.equal('xx508xx63817x752xx74004x30705xx92x58349x5x78f5xx34xxxxx51');
    });

    it('Input settings bearer be empty if no authorization bearer exists', () => {
      const args = {
        __ow_headers: {
          authorization: 'Basic user:pass',
        },
      };      const validator = new Validator<Cart>(args, 'test');
      const input = validator.setMapper(TestCartMapper).input();
      expect(input.settings.bearer).to.be.equal('');
    });

    it('Input entity should be according to the generic passed to the validator', () => {
      const validator = new Validator<Cart>(args, 'test');
      const input = validator.setMapper(TestCartMapper).input();
      expect(input.parameters.id).to.be.equal('12345');
    });

    it('Input errorOutput should be according to the performed validation', () => {
      const validator = new Validator<Cart>(args, 'test');
      const input = validator.isCurrencyCode('currency').setMapper(TestCartMapper).input();
      expect(input.errorOutput).to.be.deep.equal({
        name: 'InvalidArgumentError',
        message: 'Invalid currency code \'US\'',
        cause: {
          message: 'invalid-argument',
        },
      });
    });

    it('Input errorOutput should return a not implemented error when the isNotImplemented validation is used.', () => {
      const validator = new Validator<Cart>(args, 'test');
      const input = validator.isNotImplemented().input();
      expect(input.errorOutput).to.be.deep.equal({
        cause: {
          message: 'not-implemented',
        },
        message: 'Not implemented',
        name: 'NotImplementedError',
      });
    });

    it('Input errorOutput should return the first ocurring error.', () => {
      const validator = new Validator<Cart>(args, 'test');
      const input = validator.mandatoryParameter('notExistingParameter').isIntegerDivision().isNotImplemented().input();
      expect(input.errorOutput).to.be.deep.equal({
        cause: {
          message: 'missing-property',
        },
        message: 'Parameter \'notExistingParameter\' is missing.',
        name: 'MissingPropertyError',
      });
    });

    it('Input errorOutput should return a InvalidArgumentError if the division is not integer.', () => {
      const validator = new Validator<Cart>(args, 'test');
      const input = validator.setMapper(TestCartMapper).isIntegerDivision('offset', 'limit').input();
      expect(input.errorOutput).to.be.deep.equal({
        cause: {
          message: 'invalid-argument',
        },
        message: 'Division between \'offset\' and \'limit\' must be integer.',
        name: 'InvalidArgumentError',
      });

    });
  });
});
