/*
 * Copyright 2019 diconium
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable import/no-extraneous-dependencies */
/** ***********************************************************************
 *
 * ADOBE CONFIDENTIAL
 * __________________
 *
 *  Copyright 2018 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ************************************************************************* */

const _ = require('lodash');
const fs = require('fs');
const escape = require('js-string-escape');

const swaggerInbound = require('./resources/hybris/swagger.json');

function getType(object) {
    let {type} = object;
    if (!type && object.$ref) {
        const parts = object.$ref.split('/');
        type = parts[parts.length - 1];
    } else if (type === 'integer') {
        type = 'number';
    }
    return type;
}

function addProperties(properties, requiredProperties, file) {
    _.forEach(properties, (property, name) => {
        const type = getType(property);

        fs.appendFileSync(file, '    /**\n');
        fs.appendFileSync(file, `     * ${property.description}\n`);
        fs.appendFileSync(file, '     */\n');

        if (_.some(requiredProperties, el => _.includes(name, el))) {
            fs.appendFileSync(file, `    this.${name} = ${name};\n`);
        } else if (type === 'array') {
            fs.appendFileSync(file, `    this.${name} = [];\n`);
        } else {
            fs.appendFileSync(file, `    this.${name} = undefined;\n`);
        }
    });
}

function generateConstructorSignature(definition, file, ...parentClass) {
    const constructorArguments = [];
    _.forEach(definition.required, (name) => {
        let type = getType(definition.properties[name]);
        if (type === 'array' && definition.properties[name].items) {
            type = `${getType(definition.properties[name].items)}[]`;
        }
        constructorArguments.push(`${name}: ${type}`);
    });
    fs.appendFileSync(file, `  constructor(${_.join(constructorArguments, ', ')}) {\n`);
}

function addConstructor(definition, classname, file, ...parentClass) {
    fs.appendFileSync(file, '  /**\n');
    fs.appendFileSync(file, `  * Represents a ${classname}\n`);
    fs.appendFileSync(file, '  * @constructor\n');
    _.forEach(definition.required, (name) => {
        let type = getType(definition.properties[name]);
        if (type === 'array' && definition.properties[name].items) {
            type = `${getType(definition.properties[name].items)}[]`;
        }
        fs.appendFileSync(file, `  * @param {${type}} ${name}\n`);
    });
    fs.appendFileSync(file, '  */\n');
    generateConstructorSignature(definition, file, parentClass);
    if(parentClass){
        fs.appendFileSync(file, '    super();\n');
    }
    addProperties(definition.properties, definition.required, file);
    fs.appendFileSync(file, '  }\n');
}

function addFields(definition, file) {
    _.forEach(definition.properties, (property, name) => {
        let type = getType(property);

        if (type === 'array' && property.items) {
            type = `${getType(property.items)}[]`;
        }

        if (_.some(definition.required, el => _.includes(name, el))) {
            fs.appendFileSync(file, `  ${name}: ${type};\n`);
        } else {
            fs.appendFileSync(file, `  ${name}: ${type};\n`);
        }
    });
}

function addImports(definition, classname, parentClass, file) {
    const types = [];
    _.forEach(definition.properties, (property) => {
        let type = getType(property);

        if (type === 'array' && property.items) {
            type = getType(property.items);
        }
        types.push(type);
    });

    const unique = types.filter((value, index, self) => self.indexOf(value) === index && (/^[A-Z]/.test(value) || value === 'errorList' || value === 'error') && value !== classname);
    fs.appendFileSync(file, `import { ${parentClass} } from '../${parentClass}';\n`);

    _.forEach(unique, (type) => {
        fs.appendFileSync(file, `import { ${type} } from './${type}';\n`);
    });
}

function createClass(definition, classname, parentClass, path) {
    const file = fs.openSync(`${path}/${classname}.ts`, 'w');
    console.log(`Creating class for ${classname}`);
    addImports(definition, classname, parentClass, file);

    fs.appendFileSync(file, `/**
* Auto generated code based on Swagger definition.
* Dot not edit manually. Manual changes will be overridden.
*
* @version ${escape(swaggerInbound.info.version)}
*/
`);
    /* Support inheritance by making a class extend another one */
    if (parentClass) {
        fs.appendFileSync(file, `export class ${classname} extends ${parentClass} {\n`);
        addFields(definition, file);
        addConstructor(definition, classname, file, parentClass);
    } else {
        fs.appendFileSync(file, `export class ${classname} {\n`);
        addFields(definition, file);
        addConstructor(definition, classname, file);
    }

    fs.appendFileSync(file, '}\n');
}

console.log('### Creating Generated Folder with the models that are imported from the swagger definition. ###');

const generatedModelsPath = './src/hybris-dto/models/generated';
const baseDTOClass = 'HybrisDTO';

if (!fs.existsSync(generatedModelsPath)) {
    fs.mkdirSync(generatedModelsPath);
}
// Generates all JS model classes
_.forEach(swaggerInbound.definitions, (definition, classname) => {
    createClass(definition, escape(classname), escape(baseDTOClass), generatedModelsPath);
});
