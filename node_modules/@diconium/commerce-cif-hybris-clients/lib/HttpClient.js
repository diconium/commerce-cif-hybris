"use strict";
/*
 * Copyright 2019 diconium
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const node_fetch_1 = __importDefault(require("node-fetch"));
const commerce_cif_hybris_i18n_1 = require("@diconium/commerce-cif-hybris-i18n");
const CommerceServiceResourceNotFoundError = require('@adobe/commerce-cif-common/exception').CommerceServiceResourceNotFoundError;
const CommerceServiceBadRequestError = require('@adobe/commerce-cif-common/exception').CommerceServiceBadRequestError;
const CommerceServiceForbiddenError = require('@adobe/commerce-cif-common/exception').CommerceServiceForbiddenError;
const UnexpectedError = require('@adobe/commerce-cif-common/exception').UnexpectedError;
const log = require('loglevel');
class HttpClient {
    constructor(input) {
        this.input = input;
        this.input.settings.LOG_LEVEL ? log.setLevel(this.input.settings.LOG_LEVEL) : log.setLevel('INFO');
    }
    get(path, parameters = {}) {
        return this.doRESToperation(path, undefined, parameters, 'GET');
    }
    post(path, body, parameters = {}) {
        return this.doRESToperation(path, body, parameters, 'POST');
    }
    put(path, body, parameters = {}) {
        return this.doRESToperation(path, body, parameters, 'PUT');
    }
    patch(path, body, parameters = {}) {
        return this.doRESToperation(path, body, parameters, 'PATCH');
    }
    delete(path, parameters = {}) {
        return this.doRESToperation(path, undefined, parameters, 'DELETE');
    }
    doRESToperation(path, body, parameters = {}, method) {
        const { bearer: accessToken, optionalHeaders, contentType = 'application/json; charset=UTF-8', operationType, queryParameters, } = parameters;
        const headers = Object.assign({}, optionalHeaders, { 'Content-Type': contentType, Accept: 'application/json' });
        const options = { headers, method, body: this.parseBody(body, contentType) };
        const requestId = process.env.__OW_ACTIVATION_ID;
        const params = {
            options,
            accessToken,
            url: this.buildUrl(path, queryParameters, operationType),
            reqId: requestId,
        };
        return this.execRequest(params).catch(error => Promise.reject(error));
    }
    parseBody(body, contentType) {
        if (body) {
            return contentType === 'application/json; charset=UTF-8' ? JSON.stringify(body) : body;
        }
        return undefined;
    }
    buildUrl(path, queryParameters, operationType) {
        const url = this.setBaseUrl(operationType, path);
        this.setUrlQueryParameters(queryParameters, url);
        return url;
    }
    setBaseUrl(operationType, path) {
        const { HB_BASESITEID, HB_API_HOST, HB_API_BASE_PATH, HB_OAUTH_HOST, HB_USER, HB_PASSWORD, HB_AUTH, HB_PROTOCOL, } = this.input.settings;
        let url;
        if (operationType === 'oAuth') {
            url = new url_1.URL(path, `${HB_PROTOCOL}://${HB_OAUTH_HOST}`);
        }
        else {
            url = new url_1.URL(`${HB_API_BASE_PATH}${HB_BASESITEID}${path}`, `${HB_PROTOCOL}://${HB_API_HOST}`);
            this.setUrlBasicAuthentication({ url, auth: HB_AUTH, user: HB_USER, password: HB_PASSWORD });
        }
        return url;
    }
    setUrlBasicAuthentication(builder) {
        if (builder.auth === 'basic') {
            builder.url.username = builder.user;
            builder.url.password = builder.password;
        }
    }
    setUrlQueryParameters(queryParameters, url) {
        for (const key in queryParameters) {
            const value = queryParameters[key];
            if (value) {
                url.searchParams.set(key, value);
            }
        }
    }
    execRequest(params) {
        const start = process.hrtime();
        return node_fetch_1.default(this.getAuthenticatedUrl(params), params.options)
            .then(response => this.handleResponse(response, params, start))
            .catch((error) => {
            throw error;
        });
    }
    getAuthenticatedUrl(params) {
        const { url } = params;
        if (params.accessToken) {
            url.searchParams.set('access_token', params.accessToken);
        }
        url.searchParams.set('lang', commerce_cif_hybris_i18n_1.dahcTranslator.getLocale());
        return url.toLocaleString();
    }
    handleResponse(response, params, start) {
        if (!response.ok) {
            return this.handleError(response.json(), params, start)
                .then((response) => {
                throw response;
            })
                .catch(error => Promise.reject(error));
        }
        return response.json()
            .then((response) => {
            this.logRequest(params, start);
            return Promise.resolve(response);
        })
            .catch((response) => {
            this.logRequest(params, start, response.errors);
            return Promise.reject(response);
        });
    }
    handleError(response, params, start) {
        return response
            .then((response) => {
            if (response.error) { // should be response.errors?
                this.logRequest(params, start, response.errors);
                return this.getErrorResponseFromAuthenticationServer(response);
            }
            this.logRequest(params, start, response.errors);
            return this.getErrorResponseFromRegularEndpoint(response);
        })
            .catch((error) => {
            this.logRequest(params, start, error);
            Promise.reject(new UnexpectedError(error.message, { message: 'unexpected--handle-error' }));
        });
    }
    getErrorResponseFromAuthenticationServer(response) {
        return Promise.resolve(new CommerceServiceBadRequestError(response.error_description, { message: 'authentication-error' }));
    }
    getErrorResponseFromRegularEndpoint(response) {
        const { type = '', reason = '', message, } = response.errors[0];
        return Promise.resolve(this.buildError(type + reason, message));
    }
    buildError(errorType, message) {
        let error = new UnexpectedError(message, { message: 'unexpected-client-error' });
        switch (errorType) {
            default:
                break;
            case 'UnauthorizedError':
            case 'ForbiddenError':
            case 'InvalidTokenError':
                error = new CommerceServiceForbiddenError(message, { message: errorType });
                break;
            case 'CustomerErrornotFound':
            case 'CartErrornotFound':
            case 'UnknownIdentifierError':
            case 'ValidationErrorunknownIdentifier':
            case 'VoucherOperationError':
            case 'CartEntryErrornotFound':
                error = new CommerceServiceResourceNotFoundError(message, { message: errorType });
                break;
            case 'MissingServletRequestParameterError':
            case 'ValidationError':
            case 'IllegalArgumentError':
            case 'UnsupportedDeliveryModeError':
            case 'UnsupportedCurrencyError':
            case 'InsufficientStockErrornoStock':
                error = new CommerceServiceBadRequestError(message, { message: errorType });
                break;
        }
        return error;
    }
    logRequest(params, start, errors) {
        if (log.getLevel() <= log.levels.DEBUG) {
            const end = process.hrtime(start);
            const { url, options, reqId, } = params;
            console.log('[BACKEND-CALL-START]');
            console.log(`${new Date().toISOString()} [${this.getLogLevel()}] ${reqId}`);
            console.log(`${options.method} request to ${url.toLocaleString()} \nStatus: ${!errors ? 'SUCCESS' : 'FAILED with error:'}`);
            if (errors)
                console.log(JSON.stringify(errors));
            console.log(`Execution time: ${this.parseTime(end)}`);
            console.log('[BACKEND-CALL-END]');
        }
    }
    parseTime(time) {
        return `${time[0]} (s) ${time[1] / 1000000} (ms)`;
    }
    getLogLevel() {
        return Object.keys(log.levels).find(key => log.levels[key] === log.getLevel());
    }
}
exports.HttpClient = HttpClient;
//# sourceMappingURL=HttpClient.js.map