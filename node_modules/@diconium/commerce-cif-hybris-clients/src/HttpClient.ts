/*
 * Copyright 2019 diconium
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Client, DTO, Input } from '@diconium/commerce-cif-hybris-core';
import { URL } from 'url';
import { default as fetch } from 'node-fetch';
import { dahcTranslator } from '@diconium/commerce-cif-hybris-i18n';

const CommerceServiceResourceNotFoundError = require('@adobe/commerce-cif-common/exception').CommerceServiceResourceNotFoundError;
const CommerceServiceBadRequestError = require('@adobe/commerce-cif-common/exception').CommerceServiceBadRequestError;
const CommerceServiceForbiddenError = require('@adobe/commerce-cif-common/exception').CommerceServiceForbiddenError;
const UnexpectedError = require('@adobe/commerce-cif-common/exception').UnexpectedError;
const log = require('loglevel');

export abstract class HttpClient implements Client {

  input: Input;
  public request: { url: string; json: boolean };

  protected constructor(input: Input) {
    this.input = input;
    this.input.settings.LOG_LEVEL ? log.setLevel(this.input.settings.LOG_LEVEL) : log.setLevel('INFO');
  }

  abstract exec(): Promise<DTO>;

  get(path: string, parameters: any = {}): Promise<any> {

    return this.doRESToperation(path, undefined, parameters, 'GET');

  }

  post(path: string, body, parameters: any = {}): Promise<any> {

    return this.doRESToperation(path, body, parameters, 'POST');

  }

  put(path: string, body, parameters: any = {}): Promise<any> {

    return this.doRESToperation(path, body, parameters, 'PUT');
  }

  patch(path: string, body, parameters: any = {}): Promise<any> {

    return this.doRESToperation(path, body, parameters, 'PATCH');
  }

  delete(path: string, parameters: any = {}): Promise<any> {

    return this.doRESToperation(path, undefined, parameters, 'DELETE');

  }

  private doRESToperation(path: string, body, parameters: any = {}, method: string): Promise<any> {
    const {
      bearer: accessToken,
      optionalHeaders,
      contentType = 'application/json; charset=UTF-8',
      operationType,
      queryParameters,
    } = parameters;

    const headers = Object.assign({}, optionalHeaders, { 'Content-Type': contentType, Accept: 'application/json' });
    const options = { headers, method, body: this.parseBody(body, contentType) };
    const requestId = process.env.__OW_ACTIVATION_ID;

    const params = {
      options,
      accessToken,
      url: this.buildUrl(path, queryParameters, operationType),
      reqId: requestId,
    };

    return this.execRequest(params).catch(error => Promise.reject(error));
  }

  private parseBody(body, contentType) {

    if (body) {
      return contentType === 'application/json; charset=UTF-8' ? JSON.stringify(body) : body;
    }

    return undefined;
  }

  private buildUrl(path: string, queryParameters: object, operationType: string): URL {

    const url = this.setBaseUrl(operationType, path);
    this.setUrlQueryParameters(queryParameters, url);

    return url;

  }

  private setBaseUrl(operationType: string, path: string) {

    const {
      HB_BASESITEID,
      HB_API_HOST,
      HB_API_BASE_PATH,
      HB_OAUTH_HOST,
      HB_USER,
      HB_PASSWORD,
      HB_AUTH,
      HB_PROTOCOL,
    } = this.input.settings;

    let url: URL;
    if (operationType === 'oAuth') {
      url = new URL(path, `${HB_PROTOCOL}://${HB_OAUTH_HOST}`);
    } else {
      url = new URL(`${HB_API_BASE_PATH}${HB_BASESITEID}${path}`, `${HB_PROTOCOL}://${HB_API_HOST}`);
      this.setUrlBasicAuthentication({ url, auth: HB_AUTH, user: HB_USER, password: HB_PASSWORD });
    }
    return url;
  }

  private setUrlBasicAuthentication(builder) {
    if (builder.auth === 'basic') {
      builder.url.username = builder.user;
      builder.url.password = builder.password;
    }
  }

  private setUrlQueryParameters(queryParameters: object, url: URL) {
    for (const key in queryParameters) {
      const value = queryParameters[key];
      if (value) {
        url.searchParams.set(key, value);
      }
    }
  }

  private execRequest(params) {
    const start = process.hrtime();
    return fetch(this.getAuthenticatedUrl(params), params.options)
      .then(response => this.handleResponse(response, params, start))
      .catch((error) => {
        throw error;
      });
  }

  private getAuthenticatedUrl(params: any) {

    const { url } = params;

    if (params.accessToken) {
      url.searchParams.set('access_token', params.accessToken);
    }

    url.searchParams.set('lang', dahcTranslator.getLocale());

    return url.toLocaleString();
  }

  private handleResponse(response, params, start): any {
    if (!response.ok) {
      return this.handleError(response.json(), params, start)
        .then((response) => {
          throw response;
        })
        .catch(error => Promise.reject(error));
    }
    return response.json()
      .then((response) => {
        this.logRequest(params, start);
        return Promise.resolve(response);
      })
      .catch((response) => {
        this.logRequest(params, start, response.errors);
        return Promise.reject(response);
      });
  }

  private handleError(response: Promise<any>, params, start): Promise<any> {
    return response
      .then((response) => {
        if (response.error) { // should be response.errors?
          this.logRequest(params, start, response.errors);
          return this.getErrorResponseFromAuthenticationServer(response);
        }
        this.logRequest(params, start, response.errors);
        return this.getErrorResponseFromRegularEndpoint(response);
      })
      .catch((error) => {
        this.logRequest(params, start, error);
        Promise.reject(new UnexpectedError(error.message, { message: 'unexpected--handle-error' }));
      });
  }

  private getErrorResponseFromAuthenticationServer(response)  {

    return Promise.resolve(new CommerceServiceBadRequestError(response.error_description, { message: 'authentication-error' }));
  }

  private getErrorResponseFromRegularEndpoint(response) {

    const {
      type = '',
      reason = '',
      message,
    } = response.errors[0];

    return Promise.resolve(this.buildError(type + reason, message));
  }

  private buildError(errorType, message) {
    let error = new UnexpectedError(message, { message: 'unexpected-client-error' });

    switch (errorType) {
      default:
        break;
      case 'UnauthorizedError':
      case 'ForbiddenError':
      case 'InvalidTokenError':
        error = new CommerceServiceForbiddenError(message, { message: errorType });
        break;
      case 'CustomerErrornotFound':
      case 'CartErrornotFound':
      case 'UnknownIdentifierError':
      case 'ValidationErrorunknownIdentifier':
      case 'VoucherOperationError':
      case 'CartEntryErrornotFound':
        error = new CommerceServiceResourceNotFoundError(message, { message: errorType });
        break;
      case 'MissingServletRequestParameterError':
      case 'ValidationError':
      case 'IllegalArgumentError':
      case 'UnsupportedDeliveryModeError':
      case 'UnsupportedCurrencyError':
      case 'InsufficientStockErrornoStock':
        error = new CommerceServiceBadRequestError(message, { message: errorType });
        break;
    }
    return error;
  }

  private logRequest(params, start, errors?) {

    if (log.getLevel() <= log.levels.DEBUG) {
      const end = process.hrtime(start);
      const {
        url,
        options,
        reqId,
      } = params;

      console.log('[BACKEND-CALL-START]');
      console.log(`${new Date().toISOString()} [${ this.getLogLevel() }] ${reqId}`);
      console.log(`${options.method} request to ${url.toLocaleString()} \nStatus: ${!errors ? 'SUCCESS' : 'FAILED with error:'}`);
      if (errors) console.log(JSON.stringify(errors));
      console.log(`Execution time: ${this.parseTime(end)}`);
      console.log('[BACKEND-CALL-END]');
    }

  }

  private parseTime(time) {
    return `${time[0]} (s) ${time[1] / 1000000} (ms)`;
  }

  private getLogLevel() {
    return Object.keys(log.levels).find(key => log.levels[key] === log.getLevel());
  }
}
