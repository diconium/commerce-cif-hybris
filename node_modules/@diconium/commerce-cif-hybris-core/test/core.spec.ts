/*
 * Copyright 2019 diconium
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { expect } from 'chai';
import { CoreUtils, Input, InputSettings, MathUtils, Output, SequenceAction, SimpleAction } from '../src';
import TestMapper from './classes/mappers/TestMapper';
import { TestTranslator } from './classes/translation/TestTranslator';
import TestEntity from './classes/entities/TestEntity';
import TestClient from './classes/clients/TestClient';
import TestErrorClient from './classes/clients/TestErrorClient';

describe('@diconium/commerce-cif-hybris-core ', () => {
  describe('Unit tests', () => {

    const args = {
      HB_CATALOG: 'electronicsProductCatalog',
      HB_USER: '',
      HB_OAUTH_PATH: '/authorizationserver/oauth/token',
      HB_CLIENTSECRET: 'adobeio20180605',
      HB_PROTOCOL: 'https',
      HB_AUTH: '',
      HB_CATALOGVERSION: 'Online',
      HB_API_BASE_PATH: '/rest/v2',
      HB_API_HOST: 'b2c-accelerator.test.diconium.com',
      HB_PASSWORD: '',
      HB_OAUTH_HOST: 'b2c-accelerator.test.diconium.com',
      HB_BASESITEID: '/electronics',
      HB_CLIENTID: 'adobe_hybris_connector',
    };
    const settings = new InputSettings(args);

    describe('Actions', () => {
      it('Input setting should be according to the input values', () => {
        const action = new SimpleAction({ parameters: undefined, errorOutput: undefined, settings: undefined });
        expect(action.activate.bind(action)).to.throw(Error, 'Missing Action Parameters');
      });

      it('Simple Action Activation should return error if input have error', async () => {
        const output = await new SimpleAction<TestEntity>({
          settings,
          parameters: undefined,
          errorOutput: { type: 'TestError' },
        })
          .setMapper(TestMapper)
          .setClient(TestClient)
          .setErrorType('TestType')
          .activate();

        expect(output).to.deep.equal({
          response: {
            statusCode: 200,
            headers: {},
            error: {
              name: 'InvalidArgumentError',
              cause: {
                message: 'invalid-argument',
              },
              message: undefined,
              type: 'TestError',
            },
            errorType: 'TestType',
          },
          accessToken: '',
        });

      });

      it('Simple Action Activation should return success if client execution is fine', async () => {
        const output = await new SimpleAction<TestEntity>({
          settings,
          parameters: undefined,
          errorOutput: undefined,
        })
          .setMapper(TestMapper)
          .setClient(TestClient)
          .setErrorType('TestType')
          .activate();

        expect(output).to.be.deep.equal({
          response: {
            statusCode: 200,
            headers: {},
            body: {
              message: 'Test Client Execution',
            },
          },
          accessToken: '',
        });

      });

      it('Simple Action Activation should return error if client execution return error', async () => {
        const output = await new SimpleAction<TestEntity>({
          settings,
          parameters: undefined,
          errorOutput: undefined,
        })
          .setMapper(TestMapper)
          .setClient(TestErrorClient)
          .setErrorType('TestType')
          .activate();

        expect(output).to.deep.equal({
          response: {
            statusCode: 200,
            headers: {},
            error: {
              0: 'T',
              1: 'e',
              2: 's',
              3: 't',
              4: ' ',
              5: 'C',
              6: 'l',
              7: 'i',
              8: 'e',
              9: 'n',
              10: 't',
              11: ' ',
              12: 'E',
              13: 'x',
              14: 'e',
              15: 'c',
              16: 'u',
              17: 't',
              18: 'i',
              19: 'o',
              20: 'n',
              21: ' ',
              22: 'E',
              23: 'r',
              24: 'r',
              25: 'o',
              26: 'r',
              message: undefined,
              name: 'InvalidArgumentError',
              cause: {
                message: 'invalid-argument',
              },
            },
            errorType: 'TestType',
          },
          accessToken: '',
        });

      });

      it('Sequence Action Activation should return error if input have error', async () => {
        const input = await new SequenceAction({
          settings: undefined,
          parameters: undefined,
          errorOutput: { type: 'TestError' },
        })
          .setClient(TestClient)
          .setErrorType('TestType')
          .activate();

        expect(input).to.deep.equal({
          errorOutput: {
            type: 'TestError',
          },
          parameters: undefined,
          settings: undefined,
        });

      });

      it('Sequence Action Activation should return success if client execution is fine', async () => {
        const input = await new SequenceAction({
          settings,
          parameters: {},
          errorOutput: undefined,
        })
          .setClient(TestClient)
          .setErrorType('TestType')
          .activate();

        expect(input).to.be.deep.equal({
          settings,
          responseExtension: {},
          parameters: {},
          errorOutput: undefined,
        });

      });

      it('Sequence Action Activation should return error if client execution is wrong', async () => {
        const input = await new SequenceAction({
          settings,
          parameters: {},
          errorOutput: undefined,
        })
          .setClient(TestErrorClient)
          .setErrorType('TestType')
          .activate();

        expect(input).to.be.deep.equal({
          settings,
          parameters: {},
          errorOutput: 'Test Client Execution Error',
        });

      });
    });

    describe('Mappers', () => {
      it('Should create a Mapper instance', () => {
        const testMapper = new TestMapper(undefined);
        expect(testMapper).to.exist;
      });

      it('Should create a Mapper instance with translation service', () => {
        const testMapper = new TestMapper(settings, new TestTranslator());
        expect(testMapper).to.exist;
      });

    });

    describe('Input', () => {

      it('Should create an Input instance', () => {
        const input = new Input({ settings, parameters: {}, error: undefined });
        expect(input).to.exist;
        expect(input.parameters).to.be.deep.equal({});
        expect(input.errorOutput).to.be.undefined;
        expect(input.settings).to.be.deep.equal(settings);
      });

    });

    describe('Output', () => {

      it('Should create an Output instance without error', () => {
        const output = new Output<TestEntity>({ accessToken: '123', body: {}, error: undefined, headers: {} });
        expect(output).to.exist;
        expect(output.accessToken).to.equal('123');
        expect(output.response.statusCode).to.equal(200);
        expect(output.response.headers).to.deep.equal({
          'Set-Cookie': 'ccs-access_token=123; path=/;',
        });
        expect(output.response.body).to.deep.equal({});
        expect(output.response.error).to.be.undefined;
      });

      it('Should create an Output instance with error', () => {
        const output = new Output<TestEntity>({ body: undefined, error: {}, errorType: 'TestType', headers: {} });
        expect(output).to.exist;
        expect(output.accessToken).to.be.undefined;
        expect(output.response.statusCode).to.equal(200);
        expect(output.response.headers).to.deep.equal({});
        expect(output.response.body).to.be.undefined;
        expect(output.response.error).to.be.deep.equal({});
        expect(output.response.errorType).to.be.equal('TestType');

      });

    });

    describe('Utils', () => {

      it('Objects should be the same after copy', () => {

        const from = {
          name: 'My name',
          age: '12',
        };

        const to = {
          name: '',
          age: '',
        };

        CoreUtils.mapAllExistingProperties(from, to);

        expect(to).to.be.deep.equal(from);
      });

      it('Should return cent values', () => {
        const cents = MathUtils.parseToCents(1);
        expect(cents).to.be.equal(100);
      });

    });

  });
});
